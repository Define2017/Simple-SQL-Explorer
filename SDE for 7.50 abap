*&---------------------------------------------------------------------*
*& Report YS_SDE - Simple Data Explorer
*&---------------------------------------------------------------------*
*& version: alpha 0.1.115.93
*& Written by Yurii Sychov
*& e-mail:   ysichov@gmail.com
*& skype:    ysichov
*& blog:     https://ysychov.wordpress.com/blog/
*& LinkedIn: https://www.linkedin.com/in/ysychov/
*&---------------------------------------------------------------------*
REPORT ys_sde.
TYPES:
  BEGIN OF t_sel_row,
    sign        TYPE tvarv_sign,
    opti        TYPE tvarv_opti,
    option_icon TYPE aqadh_type_of_icon,
    low         TYPE aqadh_range_value,
    high        TYPE aqadh_range_value,
    more_icon   TYPE aqadh_type_of_icon,
    range       TYPE aqadh_t_ranges,
  END OF t_sel_row.

PARAMETERS: gv_tname TYPE tabname.

"Begin of INCLUDE YS_SDE_CLASSES.
CLASS lcl_table_viewer DEFINITION DEFERRED.
CLASS lcl_box_handler  DEFINITION DEFERRED.
CLASS lcl_data_transmitter DEFINITION DEFERRED.
CLASS lcl_sel_opt DEFINITION DEFERRED.

CLASS lcl_dd_data DEFINITION."drag&drop data
  PUBLIC  SECTION.
    DATA: m_row    TYPE i,
          m_column TYPE lvc_s_col.
ENDCLASS.

CLASS lcl_dragdrop DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      drag FOR EVENT ondrag OF cl_gui_alv_grid
        IMPORTING es_row_no e_dragdropobj e_row e_column ,
      drop FOR EVENT ondrop OF cl_gui_alv_grid
        IMPORTING es_row_no e_dragdropobj e_row.
ENDCLASS.

CLASS lcl_sql DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      read_table IMPORTING i_tabname   TYPE tabname
                           i_where     TYPE string
                           i_row_count TYPE i OPTIONAL
                 CHANGING  cr_tab      TYPE REF TO data
                           c_count     TYPE i.
ENDCLASS.

CLASS lcl_sql IMPLEMENTATION.
  METHOD read_table.
    FIELD-SYMBOLS: <f_tab> TYPE ANY TABLE.

    ASSIGN cr_tab->* TO <f_tab>.
    IF i_where IS NOT INITIAL.
      TRY.
          SELECT * FROM (i_tabname) INTO TABLE <f_tab> WHERE (i_where) ORDER BY PRIMARY KEY.
        CATCH cx_sy_dynamic_osql_semantics.
        CATCH cx_sy_dynamic_osql_syntax.
        CATCH cx_sy_conversion_no_number.
      ENDTRY.
    ELSE.
      IF i_row_count IS NOT SUPPLIED.
        SELECT * FROM (i_tabname) INTO TABLE <f_tab>.
      ELSE.
        SELECT * FROM (i_tabname) INTO TABLE <f_tab> UP TO i_row_count ROWS.
      ENDIF.
    ENDIF.
    c_count = sy-dbcnt.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_alv_common DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      refresh IMPORTING i_obj TYPE REF TO cl_gui_alv_grid,
      translate_field IMPORTING i_lang LIKE sy-ucomm OPTIONAL CHANGING c_fld TYPE lvc_s_fcat.
ENDCLASS.

CLASS lcl_alv_common IMPLEMENTATION.

  METHOD refresh.
    DATA l_stable TYPE lvc_s_stbl.
    l_stable-row = 'X'.
    l_stable-col = 'X'.
    i_obj->refresh_table_display( EXPORTING is_stable = l_stable ).
  ENDMETHOD.

  METHOD translate_field.
    DATA: lv_lang       LIKE sy-langu,
          lt_field_info TYPE TABLE OF dfies.

    IF i_lang IS NOT SUPPLIED.
      lv_lang = sy-langu.
    ELSE.
      CALL FUNCTION 'CONVERSION_EXIT_ISOLA_INPUT'
        EXPORTING
          input            = i_lang
        IMPORTING
          output           = lv_lang
        EXCEPTIONS
          unknown_language = 1
          OTHERS           = 2.
    ENDIF.

    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = c_fld-ref_table
        fieldname      = c_fld-fieldname
        langu          = lv_lang
      TABLES
        dfies_tab      = lt_field_info
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc = 0.
      READ TABLE lt_field_info INDEX 1 INTO DATA(l_info).
      IF l_info-scrtext_l IS INITIAL AND l_info-scrtext_m IS INITIAL AND l_info-scrtext_s IS INITIAL.
        MOVE l_info-fieldtext TO: c_fld-reptext, c_fld-scrtext_l, c_fld-scrtext_m, c_fld-scrtext_s .
      ELSE.
        c_fld-scrtext_l = l_info-scrtext_l.
        c_fld-scrtext_m = l_info-scrtext_m.
        c_fld-scrtext_s = l_info-scrtext_s.
        c_fld-reptext   = l_info-reptext.
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_appl DEFINITION.
  PUBLIC SECTION.

    TYPES: BEGIN OF sign_option_icon_s,
             sign          TYPE tvarv_sign,
             option        TYPE tvarv_opti,
             icon_name(64) TYPE c,
             icon          TYPE aqadh_type_of_icon,
           END OF sign_option_icon_s,

           BEGIN OF t_obj,
             alv_viewer TYPE REF TO lcl_table_viewer,
           END OF t_obj,

           BEGIN OF t_lang,
             spras TYPE spras,
             sptxt TYPE sptxt,
           END OF t_lang  .

    CLASS-DATA: m_option_icons     TYPE TABLE OF sign_option_icon_s,
                mt_lang            TYPE TABLE OF t_lang,
                mt_obj             TYPE TABLE OF t_obj, "main object table
                m_ctrl_box_handler TYPE REF TO lcl_box_handler,
                c_dragdropalv      TYPE REF TO cl_dragdrop.

    CLASS-METHODS:
      init_icons_table,
      init_lang,
      suppress_run_button,
      f4,
      exist_table IMPORTING i_tab LIKE gv_tname RETURNING VALUE(e_subrc) LIKE sy-subrc.
ENDCLASS.

CLASS lcl_create_data DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      create_table IMPORTING i_tname TYPE tabname CHANGING c_table TYPE REF TO data.
ENDCLASS.

CLASS lcl_create_data IMPLEMENTATION.
  METHOD create_table.

    FIELD-SYMBOLS: <f_tab>   TYPE ANY TABLE.
* Dynamic Table creation
    DATA: lo_struct   TYPE REF TO cl_abap_structdescr,
          lo_new_type TYPE REF TO cl_abap_structdescr,
          lo_new_tab  TYPE REF TO cl_abap_tabledescr,
          lo_type     TYPE REF TO cl_abap_typedescr,
          lt_comp     TYPE cl_abap_structdescr=>component_table.

*...............Dynamic Internal Table........................*
* 1. Getting Components from existing type
    CALL METHOD cl_abap_typedescr=>describe_by_name
      EXPORTING
        p_name         = i_tname
      RECEIVING
        p_descr_ref    = lo_type
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2.

    IF sy-subrc NE 0.
      MESSAGE 'Table Structure not found'(001) TYPE 'E' DISPLAY LIKE 'I'.
    ENDIF.

    lo_struct ?= lo_type.
    lt_comp  = lo_struct->get_components( ).

* 3. Create a New Type
    lo_new_type = cl_abap_structdescr=>create( lt_comp ).
* 4. New Table type
    lo_new_tab = cl_abap_tabledescr=>create(
                    p_line_type  = lo_new_type
                    p_table_kind = cl_abap_tabledescr=>tablekind_std
                    p_unique     = abap_false ).

* 5. data to handle the new table type
    CREATE DATA c_table TYPE HANDLE lo_new_tab.
* 6. New internal table in the fieldsymbols
    ASSIGN c_table->* TO <f_tab>.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_data_transmitter DEFINITION.
  PUBLIC SECTION.
    EVENTS: data_changed EXPORTING VALUE(e_row) TYPE t_sel_row,
             col_changed EXPORTING VALUE(e_column) TYPE lvc_fname.
    METHODS: emit IMPORTING e_row TYPE t_sel_row,
      emit_col IMPORTING e_column TYPE lvc_fname.
ENDCLASS.

CLASS lcl_data_transmitter IMPLEMENTATION.
  METHOD  emit.
    RAISE EVENT data_changed EXPORTING e_row = e_row.
  ENDMETHOD.

  METHOD emit_col.
    RAISE EVENT col_changed EXPORTING e_column = e_column.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_data_receiver DEFINITION.
  PUBLIC SECTION.
    DATA: mo_transmitter TYPE REF TO lcl_data_transmitter,
          lo_tab_from    TYPE REF TO lcl_table_viewer,
          lo_sel_to      TYPE REF TO lcl_sel_opt,
          m_from_field   TYPE lvc_fname,
          m_to_field     TYPE lvc_fname.
    METHODS: constructor
      IMPORTING io_transmitter TYPE REF TO lcl_data_transmitter OPTIONAL
                io_tab_from    TYPE REF TO lcl_table_viewer OPTIONAL
                io_sel_to      TYPE REF TO lcl_sel_opt OPTIONAL
                i_from_field   TYPE lvc_fname OPTIONAL
                i_to_field     TYPE lvc_fname OPTIONAL,
      shut_down,
      update FOR EVENT data_changed OF lcl_data_transmitter IMPORTING e_row,
      update_col FOR EVENT col_changed OF lcl_data_transmitter IMPORTING e_column,
      on_grid_button_click
            FOR EVENT button_click OF cl_gui_alv_grid
        IMPORTING
            es_col_id
            es_row_no.
ENDCLASS.

CLASS lcl_sel_opt DEFINITION.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF selection_display_s,
        ind         TYPE i,
        field_label TYPE lvc_fname,
        inherited   TYPE aqadh_type_of_icon,
        emitter     TYPE aqadh_type_of_icon,
        sign        TYPE tvarv_sign,
        opti        TYPE tvarv_opti,
        option_icon TYPE aqadh_type_of_icon,
        low         TYPE aqadh_range_value,
        high        TYPE aqadh_range_value,
        more_icon   TYPE aqadh_type_of_icon,
        range       TYPE aqadh_t_ranges,
        name        TYPE reptext,
        transmitter TYPE REF TO lcl_data_transmitter,
        receiver    TYPE REF TO lcl_data_receiver,
        change(1),
      END OF selection_display_s.

    DATA: mo_viewer  TYPE REF TO lcl_table_viewer,
          mo_sel_alv TYPE REF TO cl_gui_alv_grid,
          mt_fcat    TYPE lvc_t_fcat,
          mo_sel_tab TYPE TABLE OF selection_display_s.

    EVENTS: selection_done.

    METHODS:
      constructor IMPORTING io_viewer TYPE REF TO lcl_table_viewer io_container TYPE REF TO cl_gui_container,
      raise_selection_done,
      update_sel_tab,
      update_sel_row CHANGING c_sel_row TYPE selection_display_s.

  PRIVATE SECTION.

    METHODS:
      init_fcat IMPORTING i_dd_handle TYPE i,
      handle_sel_toolbar FOR EVENT toolbar OF cl_gui_alv_grid IMPORTING e_object e_interactive,
      on_f4 FOR EVENT onf4 OF cl_gui_alv_grid
        IMPORTING e_fieldname
                    es_row_no
                    er_event_data,
      on_grid_button_click FOR EVENT button_click OF cl_gui_alv_grid
        IMPORTING
            es_col_id
            es_row_no,
      on_data_changed FOR EVENT
                    data_changed OF cl_gui_alv_grid
        IMPORTING e_onf4
                    e_onf4_before
                    er_data_changed
                    sender,
      on_data_changed_finished FOR EVENT data_changed_finished OF cl_gui_alv_grid
        IMPORTING e_modified et_good_cells,
      handle_user_command FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm,
      handle_context_menu_request FOR EVENT context_menu_request
            OF cl_gui_alv_grid
        IMPORTING
            e_object
            sender.
ENDCLASS.

CLASS lcl_table_viewer DEFINITION.

  PUBLIC SECTION.

    TYPES: BEGIN OF t_column_emitter,
             column  TYPE lvc_fname,
             emitter TYPE REF TO lcl_data_transmitter,
           END OF t_column_emitter.

    DATA: m_lang             TYPE ddlanguage,
          m_tabname          TYPE tabname,
          m_count            TYPE i,
          mo_alv             TYPE REF TO cl_gui_alv_grid,
          mo_sel             TYPE REF TO lcl_sel_opt,
          mo_box             TYPE REF TO cl_gui_dialogbox_container,
          mr_table           TYPE REF TO data,
          mo_splitter        TYPE REF TO cl_gui_splitter_container,
          mo_sel_parent      TYPE REF TO cl_gui_container,
          mo_alv_parent      TYPE REF TO cl_gui_container,
          mo_alv_catalog     TYPE lvc_t_fcat,
          mo_column_emitters TYPE TABLE OF t_column_emitter,
          mo_sel_width       TYPE i,
          m_visible.

    METHODS:
      constructor IMPORTING i_tname TYPE tabname,
      get_where RETURNING VALUE(c_where) TYPE string,
      refresh_table FOR EVENT selection_done OF lcl_sel_opt.

  PRIVATE SECTION.
    METHODS:
      create_popup,
      create_alv,
      create_sel_alv,
      set_header,
      handle_tab_toolbar FOR EVENT toolbar OF cl_gui_alv_grid
        IMPORTING e_object e_interactive,

      handle_menu_button
                    FOR EVENT menu_button OF cl_gui_alv_grid
        IMPORTING e_object e_ucomm,

      handle_user_command
                    FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm.
ENDCLASS.

CLASS lcl_data_receiver IMPLEMENTATION.

  METHOD constructor.
    lo_sel_to = io_sel_to.
    m_from_field =  i_from_field.
    m_to_field =  i_to_field.

    lo_tab_from = io_tab_from.
    mo_transmitter = io_transmitter.

    IF mo_transmitter IS NOT INITIAL.
      IF lo_tab_from IS INITIAL.
        SET HANDLER me->update FOR io_transmitter.
      ELSE.
        SET HANDLER me->update_col FOR io_transmitter.
      ENDIF.
    ELSE.
      SET HANDLER me->update FOR ALL INSTANCES.
    ENDIF.
  ENDMETHOD.

  METHOD shut_down.
    IF mo_transmitter IS NOT INITIAL.
      SET HANDLER me->update FOR mo_transmitter  ACTIVATION space.
    ELSE.
      SET HANDLER me->update FOR ALL INSTANCES  ACTIVATION space.
    ENDIF.
    CLEAR lo_sel_to.
  ENDMETHOD.

  METHOD on_grid_button_click.
    FIELD-SYMBOLS: <f_tab>   TYPE STANDARD TABLE,
                   <f_field> TYPE any.
    CHECK m_from_field = es_col_id-fieldname.

    ASSIGN lo_tab_from->mr_table->* TO <f_tab>.
    READ TABLE <f_tab> INDEX es_row_no-row_id ASSIGNING FIELD-SYMBOL(<tab>).
    ASSIGN COMPONENT es_col_id-fieldname OF STRUCTURE <tab> TO  <f_field>.

    CHECK lo_sel_to IS NOT INITIAL.
    READ TABLE lo_sel_to->mo_sel_tab ASSIGNING FIELD-SYMBOL(<to>) WITH KEY field_label = m_to_field.
    CLEAR: <to>-high, <to>-opti, <to>-sign, <to>-range.
    <to>-low = <f_field>.
    lo_sel_to->update_sel_row( CHANGING c_sel_row = <to> ).

    IF <to>-transmitter IS BOUND.
      DATA: ls_row TYPE t_sel_row.
      MOVE-CORRESPONDING <to> TO ls_row.
      <to>-transmitter->emit( EXPORTING e_row = ls_row ).
    ENDIF.

    lcl_alv_common=>refresh( lo_sel_to->mo_sel_alv ).
    lo_sel_to->raise_selection_done( ).
  ENDMETHOD.

  METHOD  update.
    DATA: l_updated.

    READ TABLE lo_sel_to->mo_sel_tab ASSIGNING FIELD-SYMBOL(<to>) WITH KEY field_label = m_to_field.

    IF <to>-range[] = e_row-range[].
      l_updated = 'X'."so as not to have an infinite event loop
    ENDIF.
    MOVE-CORRESPONDING e_row TO <to>.

    IF <to>-transmitter IS BOUND AND l_updated IS INITIAL.
      <to>-transmitter->emit( EXPORTING e_row = e_row ).
    ENDIF.

    lcl_alv_common=>refresh( lo_sel_to->mo_sel_alv ).
    lo_sel_to->raise_selection_done( ).
  ENDMETHOD.

  METHOD update_col.

    DATA: lt_sel_row TYPE t_sel_row.
    FIELD-SYMBOLS: <tab>   TYPE STANDARD TABLE,
                   <field> TYPE any.

    CHECK lo_sel_to IS NOT INITIAL.
    READ TABLE lo_sel_to->mo_sel_tab ASSIGNING FIELD-SYMBOL(<to>) WITH KEY field_label = m_to_field.
    CLEAR: <to>-sign, <to>-opti, <to>-low, <to>-high, <to>-range.
    ASSIGN lo_tab_from->mr_table->* TO <tab>.

    LOOP AT <tab> ASSIGNING FIELD-SYMBOL(<row>).
      ASSIGN COMPONENT e_column OF STRUCTURE <row> TO <field>.
      READ TABLE <to>-range WITH KEY low = <field>  TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        APPEND VALUE #( sign = 'I' opti = 'EQ' low = <field> ) TO <to>-range.
      ENDIF.
    ENDLOOP.

    IF sy-subrc NE 0." empty column
      APPEND VALUE #( sign = 'I' opti = 'EQ' low = '' ) TO <to>-range.
    ENDIF.

    LOOP AT <to>-range ASSIGNING FIELD-SYMBOL(<sel>).
      <to>-low = <sel>-low.
      lo_sel_to->update_sel_row( CHANGING c_sel_row = <to> ).
      EXIT.
    ENDLOOP.

    MOVE-CORRESPONDING <to> TO lt_sel_row.

    IF <to>-transmitter IS BOUND. " AND l_updated IS INITIAL.
      <to>-transmitter->emit( EXPORTING e_row = lt_sel_row ).
    ENDIF.

    lcl_alv_common=>refresh( lo_sel_to->mo_sel_alv ).
    lo_sel_to->raise_selection_done( ).

  ENDMETHOD.
ENDCLASS.

CLASS lcl_box_handler DEFINITION."for memory clearing
  PUBLIC SECTION.
    METHODS: on_box_close FOR EVENT close OF cl_gui_dialogbox_container IMPORTING sender.
ENDCLASS.

CLASS lcl_box_handler IMPLEMENTATION.

  METHOD on_box_close.

    DATA: lv_tabix LIKE sy-tabix.
    sender->free( ).

    "Free Memory
    LOOP AT lcl_appl=>mt_obj ASSIGNING FIELD-SYMBOL(<obj>).
      IF <obj>-alv_viewer->mo_box = sender.
        lv_tabix = sy-tabix.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF sy-subrc = 0.
      FREE <obj>-alv_viewer->mr_table.
      FREE <obj>-alv_viewer->mo_alv.

      "shutdown receivers.
      IF <obj>-alv_viewer->mo_sel IS NOT INITIAL.
        LOOP AT <obj>-alv_viewer->mo_sel->mo_sel_tab INTO DATA(l_sel).
          IF l_sel-receiver IS BOUND.
            l_sel-receiver->shut_down( ).
          ENDIF.
        ENDLOOP.
      ENDIF.
      FREE <obj>-alv_viewer.

      DELETE lcl_appl=>mt_obj INDEX lv_tabix.
    ENDIF.
  ENDMETHOD.                    "ON_BOX_CLOSE
ENDCLASS.               "lcl_box_handler

CLASS lcl_table_viewer IMPLEMENTATION.

  METHOD constructor.
    m_lang = sy-langu.
    mo_sel_width = 0.
    m_tabname = i_tname.
    create_popup( ).
    lcl_create_data=>create_table( EXPORTING i_tname = m_tabname CHANGING c_table = mr_table ).
    create_alv( ).
  ENDMETHOD.

  METHOD create_popup.
    DATA: l_top  TYPE i,
          l_left TYPE i.

    DATA(l_lines) = lines( lcl_appl=>mt_obj ) - 1.

    l_top  = 20 + 30 * ( l_lines DIV 5 ) +  ( l_lines MOD 5 ) * 50.
    l_left = 350 + 300 * ( l_lines DIV 5 )  +  ( l_lines MOD 5 ) * 50.

    CREATE OBJECT mo_box
      EXPORTING
        width                       = '800'
        height                      = '150'
        top                         = l_top
        left                        = l_left
        caption                     = m_tabname
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        event_already_registered    = 6
        error_regist_event          = 7
        OTHERS                      = 8.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    CREATE OBJECT mo_splitter
      EXPORTING
        parent  = mo_box
        rows    = 1
        columns = 2
      EXCEPTIONS
        OTHERS  = 1.

    mo_splitter->set_column_mode(  mode = mo_splitter->mode_absolute ).
    mo_splitter->set_column_width( id = 1 width = mo_sel_width ).

    CALL METHOD:
     mo_splitter->get_container(  EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = mo_sel_parent ),

      mo_splitter->get_container
       EXPORTING
        row       = 1
        column    = 2
       RECEIVING
        container = mo_alv_parent.

    IF lcl_appl=>m_ctrl_box_handler IS INITIAL.
      lcl_appl=>m_ctrl_box_handler = NEW #( ).
    ENDIF.
    SET HANDLER lcl_appl=>m_ctrl_box_handler->on_box_close FOR mo_box.
  ENDMETHOD.

  METHOD create_alv.

    DATA: ls_layout  TYPE lvc_s_layo,
          effect     TYPE i,
          handle_alv TYPE i.
    FIELD-SYMBOLS: <f_tab>   TYPE ANY TABLE.

    mo_alv = NEW #( i_parent = mo_alv_parent ).
    ASSIGN mr_table->* TO <f_tab>.
    lcl_sql=>read_table( EXPORTING i_tabname = m_tabname i_where = get_where( ) i_row_count = 100
                         CHANGING cr_tab =  mr_table c_count = m_count ).

    set_header( ).
    ls_layout-zebra = 'X'.
    ls_layout-col_opt = 'X'.
    ls_layout-cwidth_opt = 'X'.
    ls_layout-sel_mode = 'D'.

    CREATE OBJECT lcl_appl=>c_dragdropalv.

    effect = cl_dragdrop=>move + cl_dragdrop=>copy.

    CALL METHOD lcl_appl=>c_dragdropalv->add
      EXPORTING
        flavor     = 'Line'
        dragsrc    = 'X'
        droptarget = 'X'
        effect     = effect.

    CALL METHOD lcl_appl=>c_dragdropalv->get_handle IMPORTING handle = handle_alv.

    ls_layout-s_dragdrop-grid_ddid = handle_alv.
    CALL METHOD mo_alv->set_table_for_first_display
      EXPORTING
        i_save           = 'X'
        i_default        = 'X'
        i_structure_name = m_tabname
        is_layout        = ls_layout
      CHANGING
        it_outtab        = <f_tab>.

    mo_alv->get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = mo_alv_catalog ).

    LOOP AT mo_alv_catalog ASSIGNING FIELD-SYMBOL(<cat>) WHERE scrtext_l IS INITIAL.
      lcl_alv_common=>translate_field(  CHANGING c_fld = <cat> ).
    ENDLOOP.

    mo_alv->set_frontend_fieldcatalog( EXPORTING  it_fieldcatalog = mo_alv_catalog ).
    SET HANDLER me->handle_user_command
                me->handle_menu_button
                me->handle_tab_toolbar
                lcl_dragdrop=>drag FOR mo_alv.

    me->handle_user_command( EXPORTING e_ucomm = 'HIDE' ).
    mo_alv->set_toolbar_interactive( ).
  ENDMETHOD.

  METHOD create_sel_alv.
    IF mo_sel IS INITIAL.
      mo_sel     = NEW #( io_viewer = me io_container = mo_sel_parent ).
      SET HANDLER refresh_table FOR mo_sel.
    ELSE.
      mo_sel->update_sel_tab( ).
    ENDIF.
  ENDMETHOD.

  METHOD set_header.
    DATA: lv_text       TYPE as4text,
          lv_header(80) TYPE c.

    SELECT SINGLE ddtext INTO lv_text
      FROM dd02t
      WHERE tabname = m_tabname
        AND ddlanguage = m_lang.

    lv_header = |{ m_tabname } - { lv_text } ({ m_count })|.
    mo_box->set_caption( lv_header ).
  ENDMETHOD.

  METHOD handle_tab_toolbar.
    IF m_visible IS INITIAL.
      DATA(lt_toolbar) = VALUE ttb_button( ( function = 'SEL_ON' icon = icon_arrow_left quickinfo = 'Select-Options' butn_type = 0 )
                                           ( butn_type = 3 ) ).
    ENDIF.

    lt_toolbar = VALUE ttb_button( BASE lt_toolbar ( function = 'LANGUAGE' icon = icon_foreign_trade quickinfo = 'LanguagesА' butn_type = 2 )
                                 ( function = 'OPTIONS'  icon = icon_list          quickinfo = 'Empty columns options'   butn_type = 2 )
                                 ( function = 'TABLES'   icon = icon_net_graphic   quickinfo = 'Table links'   butn_type = 0 )
                                 ( butn_type = 3 ) ).

    e_object->mt_toolbar =  lt_toolbar = VALUE ttb_button( BASE lt_toolbar ( LINES OF e_object->mt_toolbar ) ).
  ENDMETHOD.

  METHOD handle_menu_button.
    IF e_ucomm = 'LANGUAGE'.
      CALL METHOD e_object->add_function
        EXPORTING
          fcode = 'TECH'
          text  = 'Technical name'. "Teхническое имя
      LOOP AT lcl_appl=>mt_lang INTO DATA(ls_lang).
        CALL METHOD e_object->add_function
          EXPORTING
            fcode = CONV #( ls_lang-spras )
            text  = CONV #( ls_lang-sptxt ).
      ENDLOOP.
    ELSEIF e_ucomm = 'OPTIONS'.
      CALL METHOD e_object->add_function
        EXPORTING
          fcode = 'HIDE'
          text  = 'Hide empty columns'. "Спрятать пустые столбцы
      CALL METHOD e_object->add_function
        EXPORTING
          fcode = 'SHOW'
          text  = 'Show empty columns'. "Отобразить пустые столбцы
    ENDIF.
  ENDMETHOD.

  METHOD handle_user_command.
    DATA:
      it_fields    TYPE lvc_t_fcat,
      lv_clause    TYPE string,
      lv_sel_width TYPE i.

    FIELD-SYMBOLS: <field>  LIKE LINE OF it_fields,
                   <f_tab>  TYPE ANY TABLE,
                   <f_line> TYPE any.

    mo_alv->get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = it_fields[] ).
    ASSIGN mr_table->* TO <f_tab>.
    IF e_ucomm = 'SEL_ON' AND m_visible IS INITIAL.
      create_sel_alv( ).
      m_visible = 'X'.
      IF mo_sel_width = 0.
        lv_sel_width = 500.
      ELSE.
        lv_sel_width = mo_sel_width.
      ENDIF.

      mo_splitter->set_column_width( EXPORTING
          id    = 1
          width = lv_sel_width ).

      mo_alv->set_toolbar_interactive( ).
      RETURN.
    ENDIF.

    LOOP AT it_fields ASSIGNING <field>.
      CASE e_ucomm.
        WHEN 'HIDE'. "hide select options
          lv_clause = |{ <field>-fieldname } IS NOT INITIAL|.
          LOOP AT <f_tab> ASSIGNING <f_line>  WHERE (lv_clause).
            EXIT.
          ENDLOOP.

          IF sy-subrc NE 0.
            <field>-no_out = 'X'.
          ENDIF.

        WHEN 'SHOW'.
          <field>-no_out = ' '.
        WHEN 'TECH'. "technical field name
          <field>-scrtext_l = <field>-scrtext_m = <field>-scrtext_s =  <field>-reptext = <field>-fieldname.
        WHEN 'TABLES'.
          DATA(lt_obj) = VALUE sdg1_obj( (  obj_name = m_tabname type = 'TABL' )  ).
          CALL FUNCTION 'REPOSITORY_STRUCTURE_GRAPH'
            EXPORTING
              type    = 'TABL'
            TABLES
              objects = lt_obj.
          SET TITLEBAR 'SDE'.
          RETURN.
        WHEN OTHERS. "header names translation
          READ TABLE lcl_appl=>mt_lang WITH KEY spras = e_ucomm TRANSPORTING NO FIELDS.
          IF sy-subrc = 0.
            lcl_alv_common=>translate_field( EXPORTING i_lang = e_ucomm CHANGING c_fld = <field> ).
            IF mo_sel IS BOUND.
              TRY.
                  mo_sel->mo_sel_tab[ field_label = <field>-fieldname ]-name = <field>-scrtext_l.
                  IF mo_sel->mo_sel_tab[ field_label = <field>-fieldname ]-name IS INITIAL.
                    mo_sel->mo_sel_tab[ field_label = <field>-fieldname ]-name = <field>-reptext.
                  ENDIF.
                CATCH cx_sy_itab_line_not_found.
              ENDTRY.
            ENDIF.
          ENDIF.
      ENDCASE.
    ENDLOOP.

    READ TABLE lcl_appl=>mt_lang WITH KEY spras = e_ucomm TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      m_lang = e_ucomm.
      set_header( ).
    ENDIF.

    CALL METHOD mo_alv->set_frontend_fieldcatalog EXPORTING it_fieldcatalog = it_fields[].
    lcl_alv_common=>refresh( mo_alv ).
    IF mo_sel IS BOUND.
      IF  e_ucomm = 'HIDE' OR e_ucomm = 'SHOW'.
        mo_sel->update_sel_tab( ).
      ENDIF.
      lcl_alv_common=>refresh( mo_sel->mo_sel_alv ).
    ENDIF.
  ENDMETHOD.                           "handle_user_command

  METHOD get_where."dynamic where clause

    DATA: lv_sentence TYPE string,lv_opt TYPE string,
          lv_not      TYPE string.

    IF  mo_sel IS NOT INITIAL.
      LOOP AT mo_sel->mo_sel_tab INTO DATA(ls_tab) WHERE range IS NOT INITIAL.
        CLEAR lv_opt.
        LOOP AT ls_tab-range ASSIGNING FIELD-SYMBOL(<range>).
          IF mo_alv_catalog[ fieldname = ls_tab-field_label ]-datatype = 'DATS' AND ls_tab-sign IS NOT INITIAL.
            CALL FUNCTION 'CONVERT_DATE_TO_INTERNAL'
              EXPORTING
                date_external            = <range>-low
              IMPORTING
                date_internal            = <range>-low
              EXCEPTIONS
                date_external_is_invalid = 1
                OTHERS                   = 2.

            CALL FUNCTION 'CONVERT_DATE_TO_INTERNAL'
              EXPORTING
                date_external            = <range>-high
              IMPORTING
                date_internal            = <range>-high
              EXCEPTIONS
                date_external_is_invalid = 1
                OTHERS                   = 2.
          ENDIF.

          IF <range>-opti = 'NP'.
            <range>-opti = 'CP'.
            IF <range>-sign = 'I'.
              <range>-sign = 'E'.
            ELSE.
              <range>-sign = 'I'.
            ENDIF.
          ENDIF.

          IF <range>-sign = 'E'.
            lv_not = ' NOT'.
          ELSE.
            CLEAR lv_not.
          ENDIF.

          IF <range>-sign = 'E'.
            CASE <range>-opti.
              WHEN 'EQ'.
                <range>-opti = 'NE'.
              WHEN 'NE'.
                <range>-opti = 'EQ'.
              WHEN 'BT'.
                <range>-opti = 'NB'.
              WHEN 'NB'.
                <range>-opti = 'BT'.
            ENDCASE.
          ENDIF.

          IF <range>-opti = 'BT' OR <range>-opti = 'NB'.
            lv_sentence = |{ ls_tab-field_label }{ lv_not } BETWEEN '{ <range>-low }' AND '{ <range>-high }'|.
          ELSEIF <range>-opti = 'CP' OR <range>-opti = 'NP' .
            REPLACE ALL OCCURRENCES OF '*' IN <range>-low WITH '%'.
            REPLACE ALL OCCURRENCES OF '+' IN <range>-low WITH '_'.
            lv_sentence = |{ ls_tab-field_label }{ lv_not } LIKE '{ <range>-low }'|.
          ELSE.
            lv_sentence = |{ ls_tab-field_label } { <range>-opti } '{ <range>-low }'|.
          ENDIF.

          IF lv_opt IS INITIAL.
            lv_opt = |{ lv_sentence }|.
          ELSE.
           IF ( <range>-opti = 'BT' OR <range>-opti = 'NB' or <range>-opti = 'EQ'  ) AND <range>-sign = 'I'.
              lv_opt = |{ lv_opt } OR { lv_sentence }|.
            ELSE.
              lv_opt = |{ lv_opt } AND { lv_sentence }|.
            ENDIF.
           ENDIF.

          AT END OF sign.
            lv_opt = |( { lv_opt } ) |.
          ENDAT.
        ENDLOOP.

        IF c_where IS INITIAL.
          c_where = lv_opt.
        ELSE.
          c_where = |{ c_where } AND { lv_opt }| .
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.

  METHOD refresh_table.
    DATA: ls_row TYPE t_sel_row.
    lcl_sql=>read_table( EXPORTING i_tabname = m_tabname i_where = get_where( ) CHANGING cr_tab =  mr_table c_count = m_count ).
    set_header( ).

    LOOP AT mo_sel->mo_sel_tab  ASSIGNING FIELD-SYMBOL(<sel>)." WHERE change IS NOT INITIAL.
      IF <sel>-transmitter IS NOT INITIAL.
        MOVE-CORRESPONDING <sel> TO ls_row.
        <sel>-transmitter->emit( e_row = ls_row ).
      ENDIF.
      CLEAR <sel>-change.
    ENDLOOP.

    lcl_alv_common=>refresh( mo_alv ).

    LOOP AT mo_column_emitters INTO DATA(l_emit).
      l_emit-emitter->emit_col( l_emit-column ).
    ENDLOOP.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_sel_opt IMPLEMENTATION.
  METHOD constructor.
    DATA: ls_layout  TYPE lvc_s_layo,
          effect     TYPE i,
          handle_alv TYPE i.

    mo_viewer = io_viewer.
    mo_sel_alv = NEW #( i_parent = io_container ).
    update_sel_tab( ).
    CREATE OBJECT lcl_appl=>c_dragdropalv.
    effect =  cl_dragdrop=>copy. " + cl_dragdrop=>move.

    CALL METHOD lcl_appl=>c_dragdropalv->add
      EXPORTING
        flavor     = 'Line'
        dragsrc    = 'X'
        droptarget = 'X'
        effect     = effect.

    CALL METHOD lcl_appl=>c_dragdropalv->get_handle IMPORTING handle = handle_alv.

    ls_layout-s_dragdrop-col_ddid = handle_alv.
    init_fcat( handle_alv ).

    ls_layout-cwidth_opt = 'X'.


    "fields for F4 event handling
    DATA(gt_f4) = VALUE  lvc_t_f4( register   = 'X' chngeafter = 'X'
                             ( fieldname  = 'LOW'  )
                             ( fieldname  = 'HIGH'  ) ).

    mo_sel_alv->register_f4_for_fields( it_f4 = gt_f4 ).
    mo_sel_alv->register_edit_event( i_event_id = cl_gui_alv_grid=>mc_evt_enter ).

    SET HANDLER handle_user_command
                handle_sel_toolbar
                lcl_dragdrop=>drag
                lcl_dragdrop=>drop
                on_data_changed
                on_data_changed_finished
                on_grid_button_click
                handle_context_menu_request FOR mo_sel_alv.
    SET HANDLER on_f4 FOR ALL INSTANCES.

    CALL METHOD mo_sel_alv->set_table_for_first_display
      EXPORTING
        i_save          = 'X'
        i_default       = 'X'
        is_layout       = ls_layout
      CHANGING
        it_outtab       = mo_sel_tab[]
        it_fieldcatalog = mt_fcat.

    mo_sel_alv->set_toolbar_interactive( ).
  ENDMETHOD.

  METHOD init_fcat.
    mt_fcat = VALUE #( ( fieldname = 'IND'         coltext = '№'  outputlen = 3 )
                      ( fieldname = 'FIELD_LABEL' coltext = 'Label'  outputlen = 30 dragdropid = i_dd_handle emphasize = 'X' )
                      ( fieldname = 'SIGN'        coltext = 'SIGN'   tech = 'X')
                      ( fieldname = 'OPTI'        coltext = 'Option' tech = 'X' )
                      ( fieldname = 'OPTION_ICON' coltext = 'Option' icon = 'X' outputlen = 4 style = cl_gui_alv_grid=>mc_style_button )
                      ( fieldname = 'LOW'         coltext = 'From data' edit = 'X' lowercase = 'X' outputlen = 45 style = cl_gui_alv_grid=>mc_style_f4 )
                      ( fieldname = 'HIGH'        coltext = 'To data' edit = 'X' lowercase = 'X' outputlen = 45 style = cl_gui_alv_grid=>mc_style_f4 )
                      ( fieldname = 'MORE_ICON'   coltext = 'Range' icon = 'X'  style = cl_gui_alv_grid=>mc_style_button )
                      ( fieldname = 'RANGE'   tech = 'X'  )
                      ( fieldname = 'INHERITED'   coltext = 'Inh.' icon = 'X' outputlen = 4 seltext = 'Inherited')
                      ( fieldname = 'EMITTER'    coltext = 'Emit.' icon = 'X' outputlen = 4 seltext = 'Emitter')
                      ( fieldname = 'NAME' coltext = 'Field name'  outputlen = 60 )
                      ( fieldname = 'TRANSMITTER'   tech = 'X'  )
                      ( fieldname = 'RECEIVER'    tech = 'X'  )
                      ( fieldname = 'CHANGE'    tech = 'X'  )
                    ).
  ENDMETHOD.

  METHOD raise_selection_done.
    RAISE EVENT selection_done.
    DATA: ls_row TYPE t_sel_row.
    LOOP AT mo_sel_tab  ASSIGNING FIELD-SYMBOL(<sel>)." WHERE change IS NOT INITIAL.
      IF <sel>-transmitter IS NOT INITIAL.
        MOVE-CORRESPONDING <sel> TO ls_row.
        <sel>-transmitter->emit( e_row = ls_row ).
      ENDIF.
      CLEAR <sel>-change.
    ENDLOOP.
  ENDMETHOD.

  METHOD update_sel_tab.
    IF mo_sel_tab[] IS NOT INITIAL.
      DATA(lt_copy) = mo_sel_tab.
    ENDIF.
    CLEAR mo_sel_tab[].
    mo_viewer->mo_alv->get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = mo_viewer->mo_alv_catalog ).
    LOOP AT mo_viewer->mo_alv_catalog INTO DATA(l_catalog).
      DATA(lv_ind) = sy-tabix.
      CHECK l_catalog-no_out IS INITIAL.
      APPEND INITIAL LINE TO mo_sel_tab ASSIGNING FIELD-SYMBOL(<sel_tab>).
      READ TABLE lt_copy INTO DATA(ls_copy) WITH KEY field_label = l_catalog-fieldname.
      IF sy-subrc = 0.
        MOVE-CORRESPONDING ls_copy TO <sel_tab>.
      ELSE.
        <sel_tab>-option_icon = icon_led_inactive.
        <sel_tab>-more_icon = icon_enter_more.
      ENDIF.
      <sel_tab>-ind = lv_ind.
      <sel_tab>-field_label = l_catalog-fieldname.
      <sel_tab>-name = l_catalog-scrtext_l.
    ENDLOOP.
  ENDMETHOD.
  METHOD handle_sel_toolbar.
    e_object->mt_toolbar[] = VALUE #( butn_type = 0 disabled = ''
                                    ( function = 'SEL_OFF' icon = icon_arrow_right    quickinfo = 'Hide' )
                                    ( function = 'SEL_CLEAR' icon = icon_delete_row    quickinfo = 'Clear Select-Options' ) ).
  ENDMETHOD.

  METHOD update_sel_row. "select patterns rules
    IF c_sel_row-high IS INITIAL AND c_sel_row-opti = 'BT'.
      CLEAR c_sel_row-opti.
    ENDIF.

    IF c_sel_row-low IS NOT INITIAL AND c_sel_row-opti IS INITIAL.
      c_sel_row-sign = 'I'.
      c_sel_row-opti = 'EQ'.
      c_sel_row-change = 'X'.
    ENDIF.

    IF c_sel_row-high IS NOT INITIAL AND c_sel_row-opti NE 'NB' .
      c_sel_row-opti = 'BT'.
      c_sel_row-change = 'X'.
    ENDIF.

    IF c_sel_row-sign IS INITIAL AND c_sel_row-opti IS INITIAL.
      CLEAR: c_sel_row-low, c_sel_row-low.
      c_sel_row-change = 'X'.
    ENDIF.

    IF c_sel_row-low CA  '*%+&'.
      c_sel_row-sign = 'I'.
      c_sel_row-opti = 'CP'.
      c_sel_row-change = 'X'.
    ENDIF.

    IF c_sel_row-opti IS NOT INITIAL AND c_sel_row-sign IS INITIAL.
      c_sel_row-sign = 'I'.
      c_sel_row-change = 'X'.
    ENDIF.

    TRY.
        c_sel_row-option_icon = lcl_appl=>m_option_icons[ sign = c_sel_row-sign option = c_sel_row-opti ]-icon_name.
      CATCH cx_sy_itab_line_not_found.
    ENDTRY.

    IF c_sel_row-sign IS NOT INITIAL.
      READ TABLE c_sel_row-range ASSIGNING FIELD-SYMBOL(<range>) INDEX 1.
      IF sy-subrc NE 0.
        APPEND INITIAL LINE TO c_sel_row-range ASSIGNING <range>.
      ENDIF.
      MOVE-CORRESPONDING c_sel_row TO <range>.
      IF c_sel_row-opti NE 'BT' AND c_sel_row-opti NE 'NB' .
        CLEAR c_sel_row-high.
      ENDIF.
    ENDIF.
    c_sel_row-more_icon = COND #( WHEN c_sel_row-range IS INITIAL THEN icon_enter_more    ELSE icon_display_more  ).

    IF c_sel_row-receiver IS BOUND AND c_sel_row-inherited IS INITIAL.
      c_sel_row-inherited = icon_businav_value_chain.
    ENDIF.
  ENDMETHOD.

  METHOD on_f4.
    DATA: return_tab  TYPE STANDARD TABLE OF ddshretval,
          lv_retfield TYPE dynfnam.

    FIELD-SYMBOLS: <itab> TYPE lvc_t_modi.

    DATA(l_fname) = CONV fieldname( mo_sel_tab[ es_row_no-row_id ]-field_label ).

    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
      EXPORTING
        tabname           = mo_viewer->m_tabname "todo: change PAXXXX for PXXXX
        fieldname         = l_fname
      TABLES
        return_tab        = return_tab
        "todo: callback for  f4 dependent fields
      EXCEPTIONS
        field_not_found   = 1
        no_help_for_field = 2
        inconsistent_help = 3
        no_values_found   = 4
        OTHERS            = 5.

    lv_retfield = |{ mo_viewer->m_tabname }-{ l_fname }| .
    IF sy-subrc = 0.
      READ TABLE return_tab ASSIGNING FIELD-SYMBOL(<ret>) WITH KEY retfield = lv_retfield.
      IF sy-subrc = 0.
        ASSIGN er_event_data->m_data->* TO <itab>.
        APPEND VALUE #( row_id = es_row_no-row_id  fieldname = e_fieldname  value = <ret>-fieldval ) TO <itab>.
        er_event_data->m_event_handled = 'X'.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD on_grid_button_click.
    DATA:
      l_tabfield TYPE rstabfield,
      ls_opt     TYPE rsoptions VALUE 'XXXXXXXXXX',
      lv_sign    TYPE raldb_sign,
      lv_option  TYPE raldb_opti.

    READ TABLE mo_sel_tab INDEX es_row_no-row_id ASSIGNING FIELD-SYMBOL(<tab>).
    CASE es_col_id.
      WHEN 'OPTION_ICON'. "edit select logical expression type
        CALL FUNCTION 'SELECT_OPTION_OPTIONS'
          EXPORTING
            selctext     = 'nnnn'
            option_list  = ls_opt
          IMPORTING
            sign         = lv_sign
            option       = lv_option
          EXCEPTIONS
            delete_line  = 1
            not_executed = 2
            illegal_sign = 3
            OTHERS       = 4.
        IF sy-subrc = 0.
          <tab>-sign = lv_sign.
          <tab>-opti = lv_option.
          <tab>-change = 'X'.
        ELSEIF sy-subrc = 1.
          CLEAR: <tab>-low, <tab>-high,<tab>-sign, <tab>-opti, <tab>-range.
          <tab>-change = 'X'.
        ENDIF.
      WHEN 'MORE_ICON'. "edit ranges
        l_tabfield-tablename = mo_viewer->m_tabname.
        l_tabfield-fieldname = <tab>-field_label.

        CALL FUNCTION 'COMPLEX_SELECTIONS_DIALOG'
          EXPORTING
            title             = 'title'
            text              = 'text'
            tab_and_field     = l_tabfield
          TABLES
            range             = <tab>-range
          EXCEPTIONS
            no_range_tab      = 1
            cancelled         = 2
            internal_error    = 3
            invalid_fieldname = 4
            OTHERS            = 5.
        IF sy-subrc = 0.
          READ TABLE <tab>-range INDEX 1 INTO DATA(l_range).
          MOVE-CORRESPONDING l_range TO <tab>.
          IF <tab>-opti NE 'BT'.
            CLEAR <tab>-high.
            <tab>-change = 'X'.
          ENDIF.
        ENDIF.
    ENDCASE.

    update_sel_row( CHANGING c_sel_row = <tab> ).
    lcl_alv_common=>refresh( mo_sel_alv ).
    RAISE EVENT selection_done.
  ENDMETHOD.

  METHOD on_data_changed.
    FIELD-SYMBOLS: <field> TYPE any.
    LOOP AT er_data_changed->mt_mod_cells ASSIGNING FIELD-SYMBOL(<ls_cells>).
      READ TABLE mo_sel_tab INDEX <ls_cells>-row_id ASSIGNING FIELD-SYMBOL(<tab>).
      ASSIGN COMPONENT <ls_cells>-fieldname OF STRUCTURE <tab> TO <field>.
      <field> = <ls_cells>-value.
    ENDLOOP.
    LOOP AT mo_sel_tab  ASSIGNING <tab>.
      update_sel_row( CHANGING c_sel_row = <tab> ).
    ENDLOOP.
    lcl_alv_common=>refresh( mo_sel_alv ).
  ENDMETHOD.

  METHOD on_data_changed_finished.
    CHECK e_modified IS NOT INITIAL.
    RAISE EVENT selection_done.
  ENDMETHOD.

  METHOD handle_context_menu_request.
    DATA: lt_fcodes    TYPE ui_funcattr,
          ls_fcode     TYPE uiattentry,
          ls_func      TYPE ui_func,
          lt_func      TYPE ui_functions,
          lt_sel_cells TYPE lvc_t_cell,
          lt_sel_rows  TYPE lvc_t_row,
          l_index      TYPE lvc_index.

    mo_sel_alv->get_selected_cells( IMPORTING et_cell = lt_sel_cells ).
    READ TABLE lt_sel_cells INTO DATA(l_cells) INDEX 1 TRANSPORTING row_id.
    IF sy-subrc = 0.
      l_index = l_cells-row_id.
    ELSE.
      mo_sel_alv->get_selected_rows( IMPORTING et_index_rows = lt_sel_rows ).
      READ TABLE lt_sel_rows INDEX 1 INTO DATA(l_row) TRANSPORTING index.
      IF sy-subrc = 0.
        l_index = l_row-index.
      ENDIF.
    ENDIF.

    IF l_index IS NOT INITIAL.
      READ TABLE mo_sel_tab INTO DATA(l_sel) INDEX l_index.
    ENDIF.

    CALL METHOD e_object->get_functions IMPORTING fcodes = lt_fcodes. "Inactivate all standard functions

    LOOP AT lt_fcodes INTO ls_fcode WHERE fcode NE '&OPTIMIZE'.
      ls_func = ls_fcode-fcode.
      APPEND ls_func TO lt_func.
    ENDLOOP.
    e_object->hide_functions( lt_func ).
    e_object->add_separator( ).

    IF l_sel-range[]  IS NOT INITIAL OR l_index IS INITIAL.
      CALL METHOD e_object->add_function
        EXPORTING
          fcode = 'SEL_CLEAR'
          text  = 'Clear Select-Options'.
    ENDIF.

    IF l_sel-receiver IS NOT INITIAL OR l_index IS INITIAL.
      CALL METHOD e_object->add_function
        EXPORTING
          fcode = 'DELR'
          text  = 'Delete receiver'.
    ENDIF.
  ENDMETHOD.

  METHOD handle_user_command.
    DATA: lv_sel_width TYPE i,
          lt_sel_rows  TYPE lvc_t_row.

    IF e_ucomm = 'SEL_OFF'. "Hide select-options alv
      mo_viewer->m_visible = ''.

      lv_sel_width = 0.
      CALL METHOD mo_viewer->mo_splitter->get_column_width
        EXPORTING
          id                = 1
        IMPORTING
          result            = mo_viewer->mo_sel_width
        EXCEPTIONS
          cntl_error        = 1
          cntl_system_error = 2
          OTHERS            = 3.

      CALL METHOD mo_viewer->mo_splitter->set_column_width
        EXPORTING
          id    = 1
          width = lv_sel_width.
      mo_viewer->mo_alv->set_toolbar_interactive( ).
      RETURN.
    ENDIF.

    IF e_ucomm = 'SEL_CLEAR' OR e_ucomm = 'DELR'. "clear all selections
      mo_sel_alv->get_selected_rows( IMPORTING et_index_rows = lt_sel_rows ).

      LOOP AT lt_sel_rows INTO DATA(l_row).
        READ TABLE mo_sel_tab ASSIGNING FIELD-SYMBOL(<sel>) INDEX l_row-index.
        IF e_ucomm = 'SEL_CLEAR'.
          CLEAR : <sel>-low, <sel>-high, <sel>-sign, <sel>-opti, <sel>-range.
        ELSEIF e_ucomm = 'DELR'.
          IF <sel>-receiver IS NOT INITIAL.
            <sel>-receiver->shut_down( ).
            FREE <sel>-receiver.
            CLEAR <sel>-receiver.
            CLEAR <sel>-inherited.
          ENDIF.
        ENDIF.
        update_sel_row( CHANGING c_sel_row = <sel> ).
      ENDLOOP.

      lcl_alv_common=>refresh( mo_sel_alv ).
      RAISE EVENT selection_done.
    ENDIF.

    lcl_alv_common=>refresh( mo_viewer->mo_alv ).
    RAISE EVENT selection_done.
  ENDMETHOD.                           "handle_user_command
ENDCLASS.

CLASS lcl_appl IMPLEMENTATION.
  METHOD init_icons_table.
    m_option_icons = VALUE #( ( sign = space option = space  icon_name = icon_led_inactive )
                              ( sign = 'I'   option = 'EQ'   icon_name = icon_equal_green )
                              ( sign = 'I'   option = 'NE'   icon_name = icon_not_equal_green )
                              ( sign = 'I'   option = 'LT'   icon_name = icon_less_green )
                              ( sign = 'I'   option = 'LE'   icon_name = icon_less_equal_green )
                              ( sign = 'I'   option = 'GT'   icon_name = icon_greater_green )
                              ( sign = 'I'   option = 'GE'   icon_name = icon_greater_equal_green )
                              ( sign = 'I'   option = 'CP'   icon_name = icon_pattern_include_green )
                              ( sign = 'I'   option = 'NP'   icon_name = icon_pattern_exclude_green )
                              ( sign = 'I'   option = 'BT'   icon_name = icon_interval_include_green )
                              ( sign = 'I'   option = 'NB'   icon_name = icon_interval_exclude_green )
                              ( sign = 'E'   option = 'EQ'   icon_name = icon_equal_red )
                              ( sign = 'E'   option = 'NE'   icon_name = icon_not_equal_red )
                              ( sign = 'E'   option = 'LT'   icon_name = icon_less_red )
                              ( sign = 'E'   option = 'LE'   icon_name = icon_less_equal_red )
                              ( sign = 'E'   option = 'GT'   icon_name = icon_greater_red )
                              ( sign = 'E'   option = 'GE'   icon_name = icon_greater_equal_red )
                              ( sign = 'E'   option = 'CP'   icon_name = icon_pattern_include_red )
                              ( sign = 'E'   option = 'NP'   icon_name = icon_pattern_exclude_red )
                              ( sign = 'E'   option = 'BT'   icon_name = icon_interval_include_red )
                              ( sign = 'E'   option = 'NB'   icon_name = icon_interval_exclude_red )
                             ).
  ENDMETHOD.

  METHOD init_lang.
    SELECT c~spras t~sptxt INTO CORRESPONDING FIELDS OF TABLE mt_lang
      FROM t002c AS c
      INNER JOIN t002t AS t
      ON c~spras = t~sprsl
      WHERE t~spras = sy-langu
      ORDER BY c~ladatum DESCENDING c~lauzeit DESCENDING.
  ENDMETHOD.

  METHOD suppress_run_button.
    DATA itab TYPE TABLE OF sy-ucomm.
    APPEND: 'ONLI' TO itab.
    CALL FUNCTION 'RS_SET_SELSCREEN_STATUS'
      EXPORTING
        p_status  = sy-pfkey
      TABLES
        p_exclude = itab.
  ENDMETHOD.

  METHOD f4.
    DATA(lt_dynpfields) = VALUE dynpread_tabtype( ( fieldname  = 'GV_TNAME' ) ).

    CALL FUNCTION 'DYNP_VALUES_READ'
      EXPORTING
        dyname     = sy-cprog
        dynumb     = sy-dynnr
      TABLES
        dynpfields = lt_dynpfields.

    CALL FUNCTION 'F4_DD_TABLES'
      EXPORTING
        object = CONV tabname( lt_dynpfields[ 1 ]-fieldvalue )
      IMPORTING
        result = gv_tname.
  ENDMETHOD.

  METHOD exist_table.
    e_subrc = 4.
    CALL FUNCTION 'DD_EXIST_TABLE'
      EXPORTING
        tabname      = gv_tname
        status       = 'A'
      IMPORTING
        subrc        = e_subrc
      EXCEPTIONS
        wrong_status = 1
        OTHERS       = 2.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_dragdrop IMPLEMENTATION.
  METHOD drag.
    DATA: dataobj TYPE REF TO lcl_dd_data.
    CREATE OBJECT dataobj.
    dataobj->m_row = e_row-index.
    dataobj->m_column = e_column.
    e_dragdropobj->object = dataobj.
  ENDMETHOD.

  METHOD drop.
    DATA: lo_from_sel     TYPE REF TO lcl_sel_opt,
          lo_from_tab     TYPE REF TO lcl_table_viewer,
          lo_to           TYPE REF TO lcl_sel_opt,
          lo_alv          TYPE REF TO cl_gui_alv_grid,
          lt_sel_rows     TYPE lvc_t_row,
          lt_sel_cells    TYPE lvc_t_cell,
          lt_sel_col      TYPE  lvc_t_col,
          ls_row          TYPE t_sel_row,
          lv_set_receiver.

    LOOP AT lcl_appl=>mt_obj INTO DATA(lo).
      "to
      IF lo-alv_viewer->mo_sel IS BOUND.
        IF e_dragdropobj->droptargetctrl = lo-alv_viewer->mo_sel->mo_sel_alv.
          lo_to = lo-alv_viewer->mo_sel.
        ENDIF.
      ENDIF.

      "from tab
      IF lo-alv_viewer->mo_alv = e_dragdropobj->dragsourcectrl.
        lo_from_tab = lo-alv_viewer.
        CONTINUE.
      ENDIF.

      CHECK lo-alv_viewer->mo_sel IS BOUND.
      IF e_dragdropobj->dragsourcectrl = lo-alv_viewer->mo_sel->mo_sel_alv.
        lo_from_sel = lo-alv_viewer->mo_sel.
        lo-alv_viewer->mo_sel->mo_sel_alv->get_selected_rows( IMPORTING et_index_rows = lt_sel_rows ).
        lo-alv_viewer->mo_sel->mo_sel_alv->get_selected_cells( IMPORTING et_cell = lt_sel_cells ).
      ENDIF.
    ENDLOOP.

    IF lo_from_tab IS BOUND." tab to select
      FIELD-SYMBOLS: <f_tab>   TYPE STANDARD TABLE,
                     <f_str>   TYPE any,
                     <f_field> TYPE any.
      lo_from_tab->mo_alv->get_selected_cells( IMPORTING et_cell = lt_sel_cells  ).
      lo_from_tab->mo_alv->get_selected_columns( IMPORTING et_index_columns = lt_sel_col  ).

      LOOP AT lt_sel_col INTO DATA(l_col).
        TRY.
            lo_from_tab->mo_alv_catalog[ fieldname = l_col-fieldname ]-style = cl_gui_alv_grid=>mc_style_button.
          CATCH cx_sy_itab_line_not_found.
        ENDTRY.
        READ TABLE lo_from_tab->mo_column_emitters WITH KEY column = l_col ASSIGNING FIELD-SYMBOL(<emitter>).
        IF sy-subrc NE 0.
          APPEND INITIAL LINE TO lo_from_tab->mo_column_emitters ASSIGNING <emitter>.
          <emitter>-column = l_col.
          <emitter>-emitter = NEW #( ).
        ENDIF.
      ENDLOOP.

      IF sy-subrc = 0.
        lv_set_receiver = abap_true.
        CALL METHOD lo_from_tab->mo_alv->set_frontend_fieldcatalog EXPORTING it_fieldcatalog = lo_from_tab->mo_alv_catalog.
      ENDIF.

      TRY.
          ASSIGN lo_from_tab->mr_table->* TO <f_tab>.
          READ TABLE lo_to->mo_sel_tab ASSIGNING FIELD-SYMBOL(<to_tab>) INDEX e_row.
          LOOP AT lt_sel_cells INTO DATA(l_cell).
            IF sy-tabix = 1.
              DATA(l_colname) = l_cell-col_id-fieldname.
            ENDIF.
            READ TABLE <f_tab> INDEX l_cell-row_id ASSIGNING <f_str>.
            ASSIGN COMPONENT l_colname OF STRUCTURE <f_str> TO <f_field>.
            IF sy-subrc = 0.
              IF lv_set_receiver IS NOT INITIAL.
                IF <to_tab>-receiver IS BOUND.
                  <to_tab>-receiver->shut_down( ).
                ENDIF.
                CREATE OBJECT <to_tab>-receiver
                  EXPORTING
                    io_transmitter = <emitter>-emitter
                    i_from_field   = CONV #( lt_sel_cells[ 1 ]-col_id )
                    i_to_field     = <to_tab>-field_label
                    io_sel_to      = lo_to
                    io_tab_from    = lo_from_tab.
                SET HANDLER <to_tab>-receiver->on_grid_button_click FOR lo_from_tab->mo_alv.
              ENDIF.

              IF <to_tab>-range IS INITIAL.
                <to_tab>-low = <f_field>.
              ENDIF.
              READ TABLE <to_tab>-range WITH KEY low = <f_field> TRANSPORTING NO FIELDS.
              IF sy-subrc NE 0.
                APPEND VALUE #( sign = 'I' opti = 'EQ' low = <f_field>  ) TO <to_tab>-range.
              ENDIF.
            ENDIF.
          ENDLOOP.
          lo_to->update_sel_row( CHANGING c_sel_row = <to_tab> ).
        CATCH cx_sy_itab_line_not_found.
      ENDTRY.
    ENDIF.

    "select to select
    IF lo_from_sel NE lo_to.
      IF lt_sel_rows[] IS INITIAL.
        DELETE lt_sel_cells WHERE col_id NE 'FIELD_LABEL'.
        LOOP AT lt_sel_cells INTO DATA(l_sel).
          APPEND INITIAL LINE TO lt_sel_rows ASSIGNING FIELD-SYMBOL(<row>).
          <row>-index = l_sel-row_id-index.
        ENDLOOP.
      ENDIF.

      LOOP AT lt_sel_rows ASSIGNING <row>.
        READ TABLE lo_from_sel->mo_sel_tab ASSIGNING FIELD-SYMBOL(<from_tab>) INDEX <row>-index.
        IF lines( lt_sel_rows ) = 1.
          READ TABLE lo_to->mo_sel_tab ASSIGNING <to_tab> INDEX e_row.
        ELSE.
          READ TABLE lo_to->mo_sel_tab ASSIGNING <to_tab> WITH KEY field_label = <from_tab>-field_label.
          IF sy-subrc NE 0.
            CONTINUE.
          ENDIF.
        ENDIF.
        MOVE-CORRESPONDING <from_tab> TO ls_row.
        MOVE-CORRESPONDING ls_row TO <to_tab>.
        <from_tab>-emitter = icon_workflow_external_event.
        <to_tab>-inherited = icon_businav_value_chain.
        IF <from_tab>-transmitter IS INITIAL.
          CREATE OBJECT <from_tab>-transmitter.
        ENDIF.
        IF <to_tab>-receiver IS NOT INITIAL.
          <to_tab>-receiver->shut_down( ). "receiver clearing
          FREE <to_tab>-receiver.
        ENDIF.
        CREATE OBJECT <to_tab>-receiver
          EXPORTING
            io_transmitter = <from_tab>-transmitter
            io_sel_to      = lo_to
            i_to_field     = <to_tab>-field_label.
      ENDLOOP.
    ENDIF.

    lo_alv ?= e_dragdropobj->dragsourcectrl.
    lcl_alv_common=>refresh( lo_alv ).

    lo_alv ?= e_dragdropobj->droptargetctrl.
    lcl_alv_common=>refresh( lo_alv ).
    lo_to->raise_selection_done( ).
  ENDMETHOD.
ENDCLASS.
"END OF INCLUDE YS_SDE_CLASSES.

*------------REPORT EVENTS--------------------
INITIALIZATION.
  %_gv_tname_%_app_%-text = 'Enter table name and hit Enter'.
  lcl_appl=>init_lang( ).
  lcl_appl=>init_icons_table( ).

AT SELECTION-SCREEN OUTPUT.
  lcl_appl=>suppress_run_button( ).

AT SELECTION-SCREEN.
  CHECK lcl_appl=>exist_table( gv_tname ) = 0.
  APPEND INITIAL LINE TO lcl_appl=>mt_obj ASSIGNING FIELD-SYMBOL(<obj>).
  CREATE OBJECT <obj>-alv_viewer EXPORTING i_tname = gv_tname.

AT SELECTION-SCREEN ON VALUE-REQUEST FOR gv_tname.
  lcl_appl=>f4( ).
